<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Apps Corner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* General Portfolio Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
            min-height: 100vh;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 1rem;
        }
        .section-title {
            position: relative;
            padding-bottom: 0.5rem;
            display: inline-block;
        }
        .section-title::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: 0;
            width: 50%;
            height: 3px;
            background-color: #38bdf8;
            border-radius: 9999px;
        }

        /* Custom App/Game Styles */
        .app-canvas {
            display: block;
            border: 2px solid #38bdf8;
            border-radius: 0.5rem;
            margin: 1.5rem auto;
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.5); /* Blue glow */
            background-color: #000000;
        }
        .control-button {
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .control-button:hover {
            transform: translateY(-1px);
        }
        .control-button:active {
            transform: translateY(0);
        }

        /* Info Bar for all apps */
        .app-info {
            background-color: #1e293b;
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap; 
        }
        .app-info > div {
            padding: 0 0.5rem;
        }

        /* Tab Styles */
        .tab-button {
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            border-radius: 0.5rem 0.5rem 0 0;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            border: 2px solid transparent;
            margin-right: 0.5rem;
            background-color: #1e293b; /* Set base background */
        }
        .tab-button.active {
            /* Active state styles are now applied directly via JS using Tailwind classes */
            color: #38bdf8; /* Blue text */
            border-color: #38bdf8; /* Blue border */
            border-bottom: none;
        }
        /* Default inactive color setup in JS */
        
        .tab-content {
            background-color: #1e293b;
            padding: 1.5rem;
            border-radius: 0 0.5rem 0.5rem 0.5rem;
        }
    </style>
</head>
<body>

    <!-- Navigation Bar -->
    <header class="sticky top-0 z-50 bg-[#0d1117]/95 backdrop-blur-sm shadow-md">
        <nav class="container flex justify-between items-center h-16">
            <div class="text-xl font-bold text-white tracking-wider">SUKRUT MANNARI</div>
            <div class="space-x-4 text-sm font-medium">
                <a href="index.html" class="hover:text-blue-400 transition-colors">Home</a>
                <a href="projects.html" class="hover:text-blue-400 transition-colors">Projects</a>
                <a href="games.html" class="text-blue-400 transition-colors">Apps & Games</a>
                <a href="music.html" class="hover:text-blue-400 transition-colors">Music</a>
                <a href="extracurriculars.html" class="hover:text-blue-400 transition-colors">Extracurriculars</a>
                <a href="index.html#connect" class="hover:text-blue-400 transition-colors">Connect</a>
            </div>
        </nav>
    </header>

    <main class="py-12">
        <section class="container">
            <h1 class="text-4xl font-extrabold text-white mb-4">Interactive Apps & Games Corner</h1>
            <p class="text-xl text-gray-400 mb-8">
                A collection of interactive applications and games built with JavaScript and Canvas.
            </p>

            <!-- Game/App Tabs -->
            <div class="mb-4">
                <!-- Removed explicit Tailwind classes from HTML to be fully managed by JS for consistency -->
                <button id="tab-astro" class="tab-button">Astro Shooter</button>
                <button id="tab-snake" class="tab-button">Classic Snake</button>
                <button id="tab-defense" class="tab-button">Tower Defense</button>
                <button id="tab-interstellar" class="tab-button">Interstellar Browser</button> 
            </div>

            <!-- Game Content Area -->
            <div class="tab-content">
                <!-- Astro Shooter Game -->
                <div id="app-astro">
                    <h2 class="text-2xl font-bold text-blue-400 mb-4 section-title">Astro Shooter (Use WASD/Arrows and Space)</h2>
                    <canvas id="astroCanvas" class="app-canvas" width="600" height="400"></canvas>
                    <div class="app-info text-white">
                        <div id="astroScore">Score: 0</div>
                        <div id="astroLives">Lives: 3</div>
                        <div id="astroMessage" class="text-red-400 font-bold"></div>
                    </div>
                    <div class="flex justify-center space-x-4 mt-4">
                        <button id="astroStart" class="control-button bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg">Start Game</button>
                    </div>
                </div>

                <!-- Classic Snake Game -->
                <div id="app-snake" class="hidden">
                    <h2 class="text-2xl font-bold text-blue-400 mb-4 section-title">Classic Snake (Use WASD or Arrow Keys)</h2>
                    <canvas id="snakeCanvas" class="app-canvas" width="400" height="400"></canvas>
                    <div class="app-info text-white">
                        <div id="snakeScore">Score: 0</div>
                        <div id="snakeMessage" class="text-red-400 font-bold"></div>
                    </div>
                    <div class="flex justify-center space-x-4 mt-4">
                        <button id="snakeStart" class="control-button bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg">Start Game</button>
                    </div>
                </div>
                
                <!-- Tower Defense Game (Previously Interstellar Proxy Game) -->
                <div id="app-defense" class="hidden">
                    <h2 class="text-2xl font-bold text-blue-400 mb-4 section-title">Tower Defense (Click to Place Turrets - Cost: 50 points)</h2>
                    <canvas id="defenseCanvas" class="app-canvas" width="600" height="400"></canvas>
                    <div class="app-info text-white">
                        <div id="defenseScore">Points: 0</div>
                        <div id="defenseWave">Wave: 0</div>
                        <div id="defenseBaseHealth">Base Health: 100%</div>
                        <div id="defenseMessage" class="text-green-400 font-bold">Click START to begin defense!</div>
                    </div>
                    <div class="flex justify-center space-x-4 mt-4">
                        <button id="defenseStart" class="control-button bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg">Start Defense</button>
                    </div>
                </div>

                <!-- Interstellar Proxy Browser Simulation (NEW APP) -->
                <div id="app-interstellar" class="hidden">
                    <h2 class="text-2xl font-bold text-blue-400 mb-4 section-title">Interstellar Proxy Browser (Client-Side Interface)</h2>
                    <p class="text-sm text-gray-400 mb-4">
                        This interface simulates the client-side of a proxy browser by attempting to load a URL into an iframe. Note that **most websites prevent embedding** due to security headers (X-Frame-Options/CORS), which will cause a failure to load.
                    </p>
                    <div class="mb-4 flex space-x-2">
                        <input type="text" id="interstellarUrlInput" value="https://example.com" placeholder="Enter URL (e.g., https://example.com)" 
                               class="flex-grow p-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="interstellarGoButton" class="control-button bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg">Go</button>
                    </div>
                    <div id="interstellarFrameContainer" class="app-canvas" style="height: 500px; padding: 0; overflow: hidden; position: relative; background-color: #1e293b;">
                        <!-- The actual iframe will be loaded here -->
                        <p id="interstellarPlaceholder" class="p-4 text-center text-gray-400 absolute inset-0 flex items-center justify-center">
                            Enter a URL and click 'Go' to attempt loading the content in the embedded frame.
                        </p>
                    </div>
                </div>

            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="bg-[#161b22] py-4 text-center text-sm text-gray-500 mt-8">
        &copy; 2025 Sukrut Mannari. All Rights Reserved. | Powered by JavaScript Canvas.
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Global Utility to Stop Games ---
            let astroGameLoopId;
            let snakeGameInterval;
            let defenseGameLoopId;

            // --- Tab Element References ---
            const tabAstro = document.getElementById('tab-astro');
            const tabSnake = document.getElementById('tab-snake');
            const tabDefense = document.getElementById('tab-defense');
            const tabInterstellar = document.getElementById('tab-interstellar'); 
            const tabButtons = [tabAstro, tabSnake, tabDefense, tabInterstellar];

            const appAstro = document.getElementById('app-astro');
            const appSnake = document.getElementById('app-snake');
            const appDefense = document.getElementById('app-defense');
            const appInterstellar = document.getElementById('app-interstellar'); 

            // --- Canvas & Control References (Renamed for clarity) ---
            // Astro
            const astroCanvas = document.getElementById('astroCanvas');
            const astroCtx = astroCanvas.getContext('2d');
            const astroStart = document.getElementById('astroStart');
            const astroScoreDisplay = document.getElementById('astroScore');
            const astroLivesDisplay = document.getElementById('astroLives');
            const astroMessage = document.getElementById('astroMessage');
            
            // Snake
            const snakeCanvas = document.getElementById('snakeCanvas');
            const snakeCtx = snakeCanvas.getContext('2d');
            const snakeStart = document.getElementById('snakeStart');
            const snakeScoreDisplay = document.getElementById('snakeScore');
            const snakeMessage = document.getElementById('snakeMessage');

            // Defense
            const defenseCanvas = document.getElementById('defenseCanvas');
            const defenseCtx = defenseCanvas.getContext('2d');
            const defenseStart = document.getElementById('defenseStart');
            const defenseScoreDisplay = document.getElementById('defenseScore');
            const defenseWaveDisplay = document.getElementById('defenseWave');
            const defenseBaseHealthDisplay = document.getElementById('defenseBaseHealth');
            const defenseMessage = document.getElementById('defenseMessage');
            
            // Interstellar Proxy Browser
            const interstellarUrlInput = document.getElementById('interstellarUrlInput');
            const interstellarGoButton = document.getElementById('interstellarGoButton');
            const interstellarFrameContainer = document.getElementById('interstellarFrameContainer');
            const interstellarPlaceholder = document.getElementById('interstellarPlaceholder');

            let isPlayingAstro = false;
            let isPlayingSnake = false;
            let isPlayingDefense = false;
            
            // --- Tab Switching Logic ---

            function switchTab(appId) {
                // Stop all games and clean up loops
                cancelAnimationFrame(astroGameLoopId);
                clearInterval(snakeGameInterval);
                cancelAnimationFrame(defenseGameLoopId); 
                
                isPlayingAstro = false;
                isPlayingSnake = false;
                isPlayingDefense = false;
                
                // Reset button texts
                astroStart.textContent = 'Start Game';
                snakeStart.textContent = 'Start Game';
                defenseStart.textContent = 'Start Defense';

                // Hide all apps
                appAstro.classList.add('hidden');
                appSnake.classList.add('hidden');
                appDefense.classList.add('hidden'); 
                appInterstellar.classList.add('hidden'); 

                // Deactivate all tabs visually
                tabButtons.forEach(button => {
                    button.classList.remove('active', 'text-blue-400');
                    button.classList.add('text-gray-400');
                });


                // Activate the selected app/game
                if (appId === 'astro') {
                    appAstro.classList.remove('hidden');
                    tabAstro.classList.add('active', 'text-blue-400');
                    tabAstro.classList.remove('text-gray-400');
                    initAstro();
                    drawAstro();
                } else if (appId === 'snake') {
                    appSnake.classList.remove('hidden');
                    tabSnake.classList.add('active', 'text-blue-400');
                    tabSnake.classList.remove('text-gray-400');
                    initSnake();
                    drawSnake();
                } else if (appId === 'defense') { 
                    appDefense.classList.remove('hidden');
                    tabDefense.classList.add('active', 'text-blue-400');
                    tabDefense.classList.remove('text-gray-400');
                    initDefense();
                    drawDefense();
                } else if (appId === 'interstellar') {
                    appInterstellar.classList.remove('hidden');
                    tabInterstellar.classList.add('active', 'text-blue-400');
                    tabInterstellar.classList.remove('text-gray-400');
                    // No initialization needed for the browser interface, just ensure placeholder is visible initially
                    if (interstellarFrameContainer.querySelector('iframe')) {
                        interstellarFrameContainer.innerHTML = '';
                        interstellarFrameContainer.appendChild(interstellarPlaceholder);
                    }
                }
            }

            tabAstro.addEventListener('click', () => switchTab('astro'));
            tabSnake.addEventListener('click', () => switchTab('snake'));
            tabDefense.addEventListener('click', () => switchTab('defense'));
            tabInterstellar.addEventListener('click', () => switchTab('interstellar')); 

            // ------------------------------------------------------------------
            // --- INTERSTELLAR PROXY BROWSER LOGIC (NEW) ---
            // ------------------------------------------------------------------

            interstellarGoButton.addEventListener('click', () => {
                let url = interstellarUrlInput.value.trim();
                
                if (!url) return;

                // Prepend protocol if missing
                if (!/^https?:\/\//i.test(url)) {
                    url = 'https://' + url;
                }

                // Clear container and remove existing frame
                interstellarFrameContainer.innerHTML = '';

                // Create iframe
                const iframe = document.createElement('iframe');
                iframe.src = url;
                iframe.width = '100%';
                iframe.height = '100%';
                iframe.style.border = 'none';
                iframe.style.backgroundColor = 'white';
                iframe.style.position = 'absolute'; // Position relative to parent container
                iframe.style.top = '0';
                iframe.style.left = '0';

                // Create Loading Indicator (optional, but good practice)
                const loadingDiv = document.createElement('div');
                loadingDiv.textContent = `Attempting to load: ${url}`;
                loadingDiv.className = 'p-4 text-center text-yellow-400 absolute inset-0 flex items-center justify-center bg-gray-900/80';
                
                interstellarFrameContainer.appendChild(loadingDiv);
                
                // Append iframe after loading indicator
                interstellarFrameContainer.appendChild(iframe);

                iframe.onload = () => {
                    // Remove loading indicator on load
                    if (interstellarFrameContainer.contains(loadingDiv)) {
                        loadingDiv.remove();
                    }
                    console.log(`Frame load attempted for: ${url}`);
                };
                
                // Note: onerror for iframe often doesn't fire correctly for X-Frame-Options/CORS blocks
                // The frame will typically just remain blank/show a browser error without triggering onerror.
                // We keep the placeholder fallback as a simple way to indicate failure.
                const checkTimeout = setTimeout(() => {
                    if (interstellarFrameContainer.contains(loadingDiv)) {
                        loadingDiv.remove();
                        // Assume failure if loading takes too long
                        interstellarFrameContainer.innerHTML = '';
                        interstellarPlaceholder.textContent = `Load attempt timed out for ${url}. Most sites block embedding via security policies (X-Frame-Options/CORS).`;
                        interstellarFrameContainer.appendChild(interstellarPlaceholder);
                    }
                }, 5000); // 5 second timeout
                
            });


            // ------------------------------------------------------------------
            // --- ASTRO SHOOTER GAME LOGIC (Restored and Cleaned) ---
            // ------------------------------------------------------------------

            let player, asteroids, bullets, score, lives, keys;
            const ASTEROID_SPAWN_RATE = 150; 
            let spawnCounter = 0;

            class Player {
                constructor() {
                    this.x = astroCanvas.width / 2;
                    this.y = astroCanvas.height - 30;
                    this.size = 15;
                    this.speed = 5;
                    this.color = '#38bdf8';
                }
                draw() {
                    astroCtx.beginPath();
                    astroCtx.moveTo(this.x, this.y - this.size);
                    astroCtx.lineTo(this.x - this.size / 1.5, this.y + this.size / 2);
                    astroCtx.lineTo(this.x + this.size / 1.5, this.y + this.size / 2);
                    astroCtx.closePath();
                    astroCtx.fillStyle = this.color;
                    astroCtx.fill();
                }
                update() {
                    if (keys['ArrowLeft'] || keys['a']) this.x -= this.speed;
                    if (keys['ArrowRight'] || keys['d']) this.x += this.speed;
                    if (keys['ArrowUp'] || keys['w']) this.y -= this.speed;
                    if (keys['ArrowDown'] || keys['s']) this.y += this.speed;

                    if (this.x < 0) this.x = 0;
                    if (this.x > astroCanvas.width) this.x = astroCanvas.width;
                    if (this.y < 0) this.y = 0;
                    if (this.y > astroCanvas.height) this.y = astroCanvas.height;
                }
            }

            class Bullet {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.radius = 3;
                    this.speed = 7;
                    this.color = 'yellow';
                }
                draw() {
                    astroCtx.beginPath();
                    astroCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    astroCtx.fillStyle = this.color;
                    astroCtx.fill();
                }
                update() {
                    this.y -= this.speed;
                }
            }

            class Asteroid {
                constructor() {
                    this.x = Math.random() * astroCanvas.width;
                    this.y = -50;
                    this.radius = Math.random() * 15 + 15; 
                    this.speed = Math.random() * 1.5 + 1; 
                    this.color = '#6b7280'; 
                }
                draw() {
                    astroCtx.beginPath();
                    astroCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    astroCtx.fillStyle = this.color;
                    astroCtx.fill();
                    astroCtx.strokeStyle = '#4b5563';
                    astroCtx.stroke();
                }
                update() {
                    this.y += this.speed;
                }
            }

            function initAstro() {
                player = new Player();
                asteroids = [];
                bullets = [];
                score = 0;
                lives = 3;
                keys = {};
                isPlayingAstro = false;
                spawnCounter = 0;

                astroScoreDisplay.textContent = `Score: ${score}`;
                astroLivesDisplay.textContent = `Lives: ${lives}`;
                astroMessage.textContent = '';
                astroStart.textContent = 'Start Game';
            }

            function drawAstro() {
                // Clear canvas and draw background
                astroCtx.fillStyle = '#0d1117';
                astroCtx.fillRect(0, 0, astroCanvas.width, astroCanvas.height);

                // Draw simple stars in the background
                astroCtx.fillStyle = '#ffffff';
                for (let i = 0; i < 50; i++) {
                    astroCtx.fillRect(Math.random() * astroCanvas.width, Math.random() * astroCanvas.height, 1, 1);
                }

                player.draw();
                bullets.forEach(b => b.draw());
                asteroids.forEach(a => a.draw());
            }

            function updateAstro() {
                if (!isPlayingAstro) return;

                player.update();
                bullets.forEach(b => b.update());
                bullets = bullets.filter(b => b.y > 0);

                spawnCounter++;
                if (spawnCounter >= ASTEROID_SPAWN_RATE) {
                    asteroids.push(new Asteroid());
                    spawnCounter = 0;
                }
                asteroids.forEach(a => a.update());

                // 1. Bullet vs Asteroid Collision
                for (let i = bullets.length - 1; i >= 0; i--) {
                    for (let j = asteroids.length - 1; j >= 0; j--) {
                        const distance = Math.hypot(bullets[i].x - asteroids[j].x, bullets[i].y - asteroids[j].y);
                        if (distance < asteroids[j].radius) {
                            bullets.splice(i, 1);
                            asteroids.splice(j, 1);
                            score += 10;
                            astroScoreDisplay.textContent = `Score: ${score}`;
                            break; 
                        }
                    }
                }

                // 2. Player vs Asteroid Collision and Off-screen removal
                for (let i = asteroids.length - 1; i >= 0; i--) {
                    const asteroid = asteroids[i];
                    const distance = Math.hypot(player.x - asteroid.x, player.y - asteroid.y);

                    if (distance < player.size + asteroid.radius * 0.5) {
                        lives--;
                        asteroids.splice(i, 1);
                        astroLivesDisplay.textContent = `Lives: ${lives}`;
                        if (lives <= 0) {
                            gameOverAstro();
                            return;
                        }
                    } else if (asteroid.y > astroCanvas.height + asteroid.radius) {
                        // Remove off-screen asteroid
                        asteroids.splice(i, 1);
                    }
                }
            }

            function gameLoopAstro() {
                if (!isPlayingAstro) return;

                updateAstro();
                drawAstro();

                astroGameLoopId = requestAnimationFrame(gameLoopAstro);
            }

            function shoot() {
                if (!isPlayingAstro) return;
                // Add a small delay/cooldown to prevent rapid fire
                if (bullets.length > 0 && (player.y - bullets[bullets.length - 1].y) < 20) return;
                bullets.push(new Bullet(player.x, player.y - player.size));
            }

            function gameOverAstro() {
                isPlayingAstro = false;
                cancelAnimationFrame(astroGameLoopId);
                astroMessage.textContent = `GAME OVER! Final Score: ${score}`;
                astroStart.textContent = 'Play Again';
            }

            document.addEventListener('keydown', (e) => {
                // Only handle controls for the active game
                if (appAstro.classList.contains('hidden')) return;

                keys[e.key] = true;
                if (isPlayingAstro && (e.key === ' ' || e.key === 'Spacebar')) {
                    e.preventDefault(); 
                    shoot();
                }
            });
            document.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });

            astroStart.addEventListener('click', () => {
                if (!isPlayingAstro) {
                    initAstro();
                    isPlayingAstro = true;
                    astroStart.textContent = 'Game Running...';
                    gameLoopAstro();
                }
            });

            // ------------------------------------------------------------------
            // --- SNAKE GAME LOGIC (Restored and Cleaned) ---
            // ------------------------------------------------------------------

            const TILE_SIZE = 20;
            const GRID_SIZE = snakeCanvas.width / TILE_SIZE; 
            let snake, food, dx, dy, snakeScore;

            function initSnake() {
                snake = [{ x: 10, y: 10 }, { x: 9, y: 10 }, { x: 8, y: 10 }];
                food = generateFood();
                dx = 1; 
                dy = 0;
                snakeScore = 0;
                isPlayingSnake = false;
                snakeScoreDisplay.textContent = `Score: ${snakeScore}`;
                snakeMessage.textContent = '';
                snakeStart.textContent = 'Start Game';
            }

            function drawSquare(x, y, color) {
                snakeCtx.fillStyle = color;
                snakeCtx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                snakeCtx.strokeStyle = '#0d1117'; 
                snakeCtx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }

            function drawSnake() {
                snakeCtx.fillStyle = '#0d1117';
                snakeCtx.fillRect(0, 0, snakeCanvas.width, snakeCanvas.height);
                
                drawSquare(food.x, food.y, '#ef4444'); 

                snake.forEach((segment, index) => {
                    const color = index === 0 ? '#38bdf8' : '#60a5fa'; 
                    drawSquare(segment.x, segment.y, color);
                });
            }

            function generateFood() {
                let newFood;
                let onSnake;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * GRID_SIZE),
                        y: Math.floor(Math.random() * GRID_SIZE)
                    };
                    onSnake = snake.some(segment => segment.x === newFood.x && segment.y === newFood.y);
                } while (onSnake);
                return newFood;
            }

            function checkCollisionSnake() {
                const head = snake[0];
                
                if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                    return true;
                }

                for (let i = 1; i < snake.length; i++) {
                    if (head.x === snake[i].x && head.y === snake[i].y) {
                        return true;
                    }
                }
                return false;
            }

            function updateSnake() {
                if (!isPlayingSnake) return;

                const head = { x: snake[0].x + dx, y: snake[0].y + dy };
                snake.unshift(head); 

                if (checkCollisionSnake()) {
                    gameOverSnake();
                    return;
                }

                if (head.x === food.x && head.y === food.y) {
                    snakeScore += 10;
                    snakeScoreDisplay.textContent = `Score: ${snakeScore}`;
                    food = generateFood(); 
                } else {
                    snake.pop(); 
                }
            }

            function gameLoopSnake() {
                if (!isPlayingSnake) return; // Added guard just in case

                updateSnake();
                drawSnake();
                
                // Re-queue the loop to maintain continuous movement if the game is still running
                if (isPlayingSnake) {
                    snakeGameInterval = setTimeout(gameLoopSnake, 150);
                }
            }

            function gameOverSnake() {
                isPlayingSnake = false;
                clearTimeout(snakeGameInterval);
                snakeMessage.textContent = `GAME OVER! Final Score: ${snakeScore}`;
                snakeStart.textContent = 'Play Again';
            }

            document.addEventListener('keydown', (e) => {
                // Only handle controls for the active game
                if (appSnake.classList.contains('hidden')) return;
                
                const key = e.key;

                const goingUp = dy === -1;
                const goingDown = dy === 1;
                const goingRight = dx === 1;
                const goingLeft = dx === -1;

                // Prevent immediate reverse direction
                if ((key === 'ArrowLeft' || key === 'a') && !goingRight) { dx = -1; dy = 0; }
                else if ((key === 'ArrowUp' || key === 'w') && !goingDown) { dx = 0; dy = -1; }
                else if ((key === 'ArrowRight' || key === 'd') && !goingLeft) { dx = 1; dy = 0; }
                else if ((key === 'ArrowDown' || key === 's') && !goingUp) { dx = 0; dy = 1; }
            });

            snakeStart.addEventListener('click', () => {
                if (!isPlayingSnake) {
                    initSnake();
                    isPlayingSnake = true;
                    snakeStart.textContent = 'Game Running...';
                    // Use setTimeout and recursion instead of setInterval for better game loop control
                    snakeGameInterval = setTimeout(gameLoopSnake, 150); 
                }
            });


            // ------------------------------------------------------------------
            // --- TOWER DEFENSE GAME LOGIC (Renamed) ---
            // ------------------------------------------------------------------

            const PROXY_COST = 50;
            const BASE_Y_POS = defenseCanvas.height - 30; // Base line
            const TURRET_RANGE_SQ = 100 * 100; // 100 pixel range squared
            const ENEMY_SPAWN_RATE_FRAMES = 150; // Frames per enemy spawn

            let defenseScore, defenseBaseHealth, defenseWave, defenseWaveProgress;
            let defenseTurrets, defenseEnemies, defenseTurretBullets;
            let enemySpawnTimer; // Timer ID for wave spawning

            // Proxy Turret Class (Static Defense)
            class ProxyTurret {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.size = 10;
                    this.rangeSq = TURRET_RANGE_SQ;
                    this.fireRate = 50; // Fire every 50 frames
                    this.fireTimer = Math.floor(Math.random() * this.fireRate); // Stagger initial firing
                }

                draw() {
                    // Draw Range Circle (semi-transparent gray)
                    defenseCtx.beginPath();
                    defenseCtx.arc(this.x, this.y, Math.sqrt(this.rangeSq), 0, Math.PI * 2);
                    defenseCtx.fillStyle = 'rgba(56, 189, 248, 0.05)'; 
                    defenseCtx.fill();
                    
                    // Turret body (light blue square)
                    defenseCtx.fillStyle = '#38bdf8';
                    defenseCtx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
                    
                    // Center dot (white)
                    defenseCtx.fillStyle = '#ffffff';
                    defenseCtx.beginPath();
                    defenseCtx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                    defenseCtx.fill();
                }

                update(enemies, bullets) {
                    this.fireTimer++;
                    if (this.fireTimer < this.fireRate) return;

                    // Find nearest enemy in range
                    let target = null;
                    let nearestDistSq = this.rangeSq;

                    enemies.forEach(enemy => {
                        const distSq = (enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2;
                        if (distSq < nearestDistSq) {
                            nearestDistSq = distSq;
                            target = enemy;
                        }
                    });

                    if (target) {
                        // Fire bullet
                        bullets.push(new ProxyBullet(this.x, this.y, target.x, target.y));
                        this.fireTimer = 0;
                    }
                }
            }

            // Enemy Class (Moves towards base)
            class ProxyEnemy {
                constructor(startX, startY, health) {
                    this.x = startX;
                    this.y = startY;
                    this.size = 10;
                    // Speed increases slightly with wave for difficulty
                    this.speed = 0.5 + defenseWave * 0.05; 
                    this.health = health;
                    this.maxHealth = health;
                    this.reward = 10;
                }

                draw() {
                    // Enemy body (red square)
                    defenseCtx.fillStyle = '#ef4444';
                    defenseCtx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
                    
                    // Health bar (above enemy)
                    const healthRatio = this.health / this.maxHealth;
                    const barWidth = 20;
                    defenseCtx.fillStyle = '#10b981'; // Green
                    defenseCtx.fillRect(this.x - barWidth / 2, this.y - this.size - 8, barWidth * healthRatio, 3);
                    defenseCtx.strokeStyle = '#fff';
                    defenseCtx.strokeRect(this.x - barWidth / 2, this.y - this.size - 8, barWidth, 3);
                }

                update() {
                    // Move straight down towards the base line
                    this.y += this.speed;
                }
            }

            // Bullet Class (Fired by Turret)
            class ProxyBullet {
                constructor(startX, startY, targetX, targetY) {
                    this.x = startX;
                    this.y = startY;
                    this.radius = 2;
                    this.speed = 5;
                    this.damage = 10;

                    // Calculate velocity towards target (normalized vector)
                    const angle = Math.atan2(targetY - startY, targetX - startX);
                    this.dx = Math.cos(angle) * this.speed;
                    this.dy = Math.sin(angle) * this.speed;
                }

                draw() {
                    defenseCtx.fillStyle = 'yellow';
                    defenseCtx.beginPath();
                    defenseCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    defenseCtx.fill();
                }

                update() {
                    this.x += this.dx;
                    this.y += this.dy;
                }
            }


            function initDefense() {
                // Clear any running spawn timers
                if (enemySpawnTimer) clearInterval(enemySpawnTimer);

                defenseScore = 100; 
                defenseBaseHealth = 100;
                defenseWave = 0;
                defenseWaveProgress = 0;
                
                defenseTurrets = [];
                defenseEnemies = [];
                defenseTurretBullets = [];
                isPlayingDefense = false;

                defenseScoreDisplay.textContent = `Points: ${defenseScore}`;
                defenseWaveDisplay.textContent = `Wave: ${defenseWave}`;
                defenseBaseHealthDisplay.textContent = `Base Health: ${defenseBaseHealth}%`;
                defenseMessage.textContent = 'Click START to begin defense!';

                drawDefense();
            }
            
            function drawDefense() {
                // Clear canvas
                defenseCtx.fillStyle = '#0d1117';
                defenseCtx.fillRect(0, 0, defenseCanvas.width, defenseCanvas.height);
                
                // Draw Base (Blue Strip at the bottom)
                defenseCtx.fillStyle = '#1e3a8a'; // Dark blue
                defenseCtx.fillRect(0, BASE_Y_POS, defenseCanvas.width, defenseCanvas.height - BASE_Y_POS);
                
                // Draw Base Health Overlay (Red/Green Bar)
                const healthRatio = defenseBaseHealth / 100;
                const healthColor = healthRatio > 0.5 ? '#10b981' : (healthRatio > 0.2 ? '#f59e0b' : '#ef4444');
                defenseCtx.fillStyle = healthColor;
                defenseCtx.fillRect(0, BASE_Y_POS, defenseCanvas.width * healthRatio, 5);

                // Draw all game objects
                defenseTurrets.forEach(t => t.draw());
                defenseEnemies.forEach(e => e.draw());
                defenseTurretBullets.forEach(b => b.draw());
            }

            function startNextWave() {
                if (!isPlayingDefense) return;

                defenseWave++;
                defenseMessage.textContent = `WAVE ${defenseWave} INCOMING!`;
                defenseWaveDisplay.textContent = `Wave: ${defenseWave}`;

                // Total enemies scale with wave
                const totalEnemies = 5 + defenseWave * 3; 

                // Use a counter to track enemies spawned in this wave
                let enemiesSpawned = 0;
                let enemiesDefeatedInWave = 0;
                defenseWaveProgress = totalEnemies; // Set total expected enemies for this wave

                // Start the spawn interval
                enemySpawnTimer = setInterval(() => {
                    if (enemiesSpawned >= totalEnemies) {
                        clearInterval(enemySpawnTimer);
                        enemySpawnTimer = null;
                        return;
                    }
                    
                    const enemyHealth = 50 + defenseWave * 15;
                    const startX = Math.random() * (defenseCanvas.width - 40) + 20;
                    defenseEnemies.push(new ProxyEnemy(startX, -50, enemyHealth));
                    enemiesSpawned++;

                }, 1000); // 1-second delay between enemies

            }

            function updateDefense() {
                if (!isPlayingDefense) return;

                // 1. Update Game Objects
                defenseTurrets.forEach(t => t.update(defenseEnemies, defenseTurretBullets));
                defenseEnemies.forEach(e => e.update());
                defenseTurretBullets.forEach(b => b.update());

                // 2. Collision Detection: Bullet vs Enemy
                let enemiesDefeatedThisFrame = 0;
                for (let i = defenseTurretBullets.length - 1; i >= 0; i--) {
                    for (let j = defenseEnemies.length - 1; j >= 0; j--) {
                        const bullet = defenseTurretBullets[i];
                        const enemy = defenseEnemies[j];
                        const distance = Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y);

                        if (distance < enemy.size) {
                            enemy.health -= bullet.damage;
                            defenseTurretBullets.splice(i, 1); // Remove bullet
                            
                            if (enemy.health <= 0) {
                                defenseScore += enemy.reward;
                                defenseEnemies.splice(j, 1); // Remove enemy
                                enemiesDefeatedThisFrame++;
                                defenseScoreDisplay.textContent = `Points: ${defenseScore}`;
                            }
                            break;
                        }
                    }
                }
                
                // 3. Enemy Reaches Base / Off-screen check
                for (let i = defenseEnemies.length - 1; i >= 0; i--) {
                    const enemy = defenseEnemies[i];
                    if (enemy.y >= BASE_Y_POS) {
                        defenseBaseHealth -= 10; // Base takes damage
                        defenseBaseHealth = Math.max(0, defenseBaseHealth);
                        defenseEnemies.splice(i, 1); // Remove enemy
                        defenseBaseHealthDisplay.textContent = `Base Health: ${defenseBaseHealth}%`;

                        if (defenseBaseHealth <= 0) {
                            gameOverDefense();
                            return;
                        }
                    }
                }

                // 4. Cleanup bullets that are off-screen
                defenseTurretBullets = defenseTurretBullets.filter(b => 
                    b.x > -10 && b.x < defenseCanvas.width + 10 && b.y > -10 && b.y < BASE_Y_POS + 10 // Increased boundary check
                );

                // 5. Check Wave completion
                // The wave is complete if all enemies are defeated AND the spawn timer is inactive
                if (defenseWaveProgress > 0 && defenseEnemies.length === 0 && enemySpawnTimer === null) {
                    defenseMessage.textContent = `Wave ${defenseWave} Complete! Preparing next wave... (+25 Points bonus)`;
                    defenseScore += 25;
                    defenseScoreDisplay.textContent = `Points: ${defenseScore}`;
                    defenseWaveProgress = 0; // Reset progress until next wave starts
                    setTimeout(startNextWave, 3000); // 3-second break between waves
                }
            }

            function gameLoopDefense() {
                if (!isPlayingDefense) return;

                updateDefense();
                drawDefense();

                defenseGameLoopId = requestAnimationFrame(gameLoopDefense);
            }

            function gameOverDefense() {
                isPlayingDefense = false;
                cancelAnimationFrame(defenseGameLoopId);
                if (enemySpawnTimer) clearInterval(enemySpawnTimer);
                defenseMessage.textContent = `DEFENSE FAILED! Final Wave: ${defenseWave}`;
                defenseStart.textContent = 'Restart Defense';
            }

            defenseStart.addEventListener('click', () => {
                if (!isPlayingDefense) {
                    initDefense();
                    isPlayingDefense = true;
                    defenseStart.textContent = 'Defense Running...';
                    gameLoopDefense();
                    startNextWave(); // Start the first wave
                }
            });

            // Handle turret placement via canvas click
            defenseCanvas.addEventListener('click', (e) => {
                if (!isPlayingDefense) return;

                const rect = defenseCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Check if the click is above the base line
                if (y < BASE_Y_POS) {
                    if (defenseScore >= PROXY_COST) {
                        // Check for collision with existing turrets (simple check)
                        const tooClose = defenseTurrets.some(t => Math.hypot(t.x - x, t.y - y) < 40);
                        
                        if (!tooClose) {
                            defenseTurrets.push(new ProxyTurret(x, y));
                            defenseScore -= PROXY_COST;
                            defenseScoreDisplay.textContent = `Points: ${defenseScore}`;
                            defenseMessage.textContent = `Turret placed. Points: ${defenseScore}`;
                        } else {
                            defenseMessage.textContent = "Too close to another turret! Need 40px spacing.";
                        }
                    } else {
                        defenseMessage.textContent = `Not enough points! Need ${PROXY_COST}.`;
                    }
                } else {
                    defenseMessage.textContent = "Cannot place turrets on the base defense zone!";
                }
            });


            // --- Initialization and Default View ---
            initAstro();
            initSnake();
            initDefense();
            
            // Ensure only Astro is visible initially and has the active styling
            switchTab('astro');
        });
    </script>
</body>
</html>
